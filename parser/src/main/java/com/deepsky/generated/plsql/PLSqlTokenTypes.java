// $ANTLR 2.7.5 (20050128): "plsql_parser.g" -> "PLSqlParser.java"$

package com.deepsky.generated.plsql;

public interface PLSqlTokenTypes {
	int EOF = 1;
	int NULL_TREE_LOOKAHEAD = 3;
	int C_MARKER = 4;
	int BAD_ML_COMMENT = 5;
	int BAD_CHARACTER = 6;
	int BAD_CHAR_LITERAL = 7;
	int BAD_NUMBER_LITERAL = 8;
	int STORAGE_SIZE = 9;
	int LT = 10;
	int LE = 11;
	int GE = 12;
	int NOT_EQ = 13;
	int CUSTOM_TOKEN = 14;
	int COLON_NEW = 15;
	int COLON_OLD = 16;
	int TABLE_NAME_SPEC = 17;
	int QUOTED_STR_START = 18;
	int QUOTED_STR_END = 19;
	int BAD_QUOTED_STRING = 20;
	int PLSQL_ENV_VAR = 21;
	int ANY_CHARACTER = 22;
	int IDENTIFIER = 23;
	int QUOTED_STR = 24;
	int DOUBLE_QUOTED_STRING = 25;
	int AT_PREFIXED = 26;
	int SEMI = 27;
	int COLON = 28;
	int DOT = 29;
	int COMMA = 30;
	int ASTERISK = 31;
	int OPEN_PAREN = 32;
	int CLOSE_PAREN = 33;
	int PLUS = 34;
	int MINUS = 35;
	int DIVIDE = 36;
	int BACKSLASH = 37;
	int EQ = 38;
	int PERCENTAGE = 39;
	int DOUBLEDOT = 40;
	int CONCAT = 41;
	int START_LABEL = 42;
	int DOLLAR = 43;
	int END_LABEL = 44;
	int ASSIGNMENT_EQ = 45;
	int PASS_BY_NAME = 46;
	int VERTBAR = 47;
	int GT = 48;
	int NUMBER = 49;
	int N = 50;
	int WS = 51;
	int LF = 52;
	int SL_COMMENT = 53;
	int ML_COMMENT = 54;
	int IF_COND_CMPL = 55;
	int THEN_COND_CMPL = 56;
	int ELSE_COND_CMPL = 57;
	int END_COND_CMPL = 58;
	int ERROR_COND_CMPL = 59;
	int START_RULE = 60;
	int ERROR_TOKEN_A = 61;
	int PACKAGE_SPEC = 62;
	int PACKAGE_BODY = 63;
	int PACKAGE_NAME = 64;
	int PACKAGE_OBJ_BODY = 65;
	int RECORD_TYPE_DECL = 66;
	int SELECT_EXPRESSION = 67;
	int SELECT_EXPRESSION_UNION = 68;
	int PLSQL_BLOCK = 69;
	int PLSQL_BLOCK_END = 70;
	int CURSOR_DECLARATION = 71;
	int VARIABLE_DECLARATION = 72;
	int PROCEDURE_BODY = 73;
	int FUNCTION_BODY = 74;
	int PARAMETER_SPEC = 75;
	int IF_STATEMENT = 76;
	int LOOP_STATEMENT = 77;
	int STATEMENT = 78;
	int TABLE_REFERENCE_LIST = 79;
	int TABLE_REFERENCE_LIST_FROM = 80;
	int WHERE_CONDITION = 81;
	int SUBQUERY = 82;
	int SQL_IDENTIFIER = 83;
	int FUNCTION = 84;
	int GROUP_FUNCTION = 85;
	int USER_FUNCTION = 86;
	int MULTIPLY = 87;
	int ARGUMENT = 88;
	int ARGUMENT_LIST = 89;
	int FIELD_NAME = 90;
	int PLSQL_EXPR_LIST_USING = 91;
	int EXPR_LIST = 92;
	int DECLARE_LIST = 93;
	int FUNCTION_CALL = 94;
	int PACKAGE_INIT_SECTION = 95;
	int CALL_ARGUMENT_LIST = 96;
	int SPEC_CALL_ARGUMENT_LIST = 97;
	int QUERY_PARTITION_CLAUSE = 98;
	int EXTRACT_OPTIONS = 99;
	int CALL_ARGUMENT = 100;
	int BASE_EXRESSION = 101;
	int COLUMN_SPEC = 102;
	int LOGICAL_AND = 103;
	int LOGICAL_OR = 104;
	int CASE_EXPRESSION_SMPL = 105;
	int CASE_EXPRESSION_SRCH = 106;
	int CASE_STATEMENT = 107;
	int COUNT_FUNC = 108;
	int SQLPLUS_ANONYM_PLSQL_BLOCK = 109;
	int RANK_FUNCTION = 110;
	int LEAD_FUNCTION = 111;
	int LAG_FUNCTION = 112;
	int TRIM_FUNC = 113;
	int DECODE_FUNC = 114;
	int COLUMN_SPEC_LIST = 115;
	int INSERT_COMMAND = 116;
	int UPDATE_COMMAND = 117;
	int DELETE_COMMAND = 118;
	int MERGE_COMMAND = 119;
	int MERGE_WHEN_COMMAND = 120;
	int STRING_LITERAL = 121;
	int NUMERIC_LITERAL = 122;
	int BOOLEAN_LITERAL = 123;
	int RETURN_TYPE = 124;
	int TYPE_SPEC = 125;
	int VARIABLE_NAME = 126;
	int COLUMN_OUTER_JOIN = 127;
	int LOGICAL_FACTOR = 128;
	int TABLE_ALIAS = 129;
	int CAST_FUNC = 130;
	int VAR_REF = 131;
	int PLSQL_VAR_REF = 132;
	int PARAMETER_REF = 133;
	int EXCEPTION_SECTION = 134;
	int EXCEPTION_HANDLER = 135;
	int SELECTED_TABLE = 136;
	int CREATE_PROCEDURE = 137;
	int CREATE_FUNCTION = 138;
	int COMMIT_STATEMENT = 139;
	int ROLLBACK_STATEMENT = 140;
	int NULL_STATEMENT = 141;
	int ASSIGNMENT_STATEMENT = 142;
	int PROCEDURE_CALL = 143;
	int RETURN_STATEMENT = 144;
	int LOCK_TABLE_STATEMENT = 145;
	int OPEN_STATEMENT = 146;
	int FETCH_STATEMENT = 147;
	int SET_TRN_STATEMENT = 148;
	int CLOSE_STATEMENT = 149;
	int OBJECT_NAME = 150;
	int PARAMETER_NAME = 151;
	int DEFAULT = 152;
	int THEN_STATEMENT = 153;
	int ELSIF_STATEMENT = 154;
	int ELSE_STATEMENT = 155;
	int STATEMENT_LIST = 156;
	int RELATION_CONDITION = 157;
	int ISNULL_CONDITION = 158;
	int LIKE_CONDITION = 159;
	int BETWEEN_CONDITION = 160;
	int IN_CONDITION = 161;
	int PARENTHESIZED_EXPR = 162;
	int ORDER_CLAUSE = 163;
	int CONNECT_CLAUSE = 164;
	int GROUP_CLAUSE = 165;
	int INTO_CLAUSE = 166;
	int FOR_UPDATE_CLAUSE = 167;
	int PARTITION_NAME = 168;
	int ASTERISK1 = 169;
	int ROWCOUNT_EXRESSION = 170;
	int MULTIPLICATION_OP = 171;
	int DIVIDE_OP = 172;
	int PLUS_OP = 173;
	int MINUS_OP = 174;
	int CONCAT_OP = 175;
	int CURSOR_NAME = 176;
	int CURSOR_NAME_REF = 177;
	int DATATYPE = 178;
	int EXTRACT_DATE_FUNC = 179;
	int ANSI_JOIN_TAB_SPEC = 180;
	int ANSI_JOIN_TAB_CONDITION = 181;
	int INTERVAL_DAY_TO_SEC_EXPR = 182;
	int INTERVAL_YEAR_TO_MONTH_EXPR = 183;
	int INTERVAL_CONST = 184;
	int USER_CONST = 185;
	int SYSDATE_CONST = 186;
	int SYSTIMESTAMP_CONST = 187;
	int CURRENT_TIMESTAMP_CONST = 188;
	int ALIAS_NAME = 189;
	int EXISTS_EXPR = 190;
	int SUBQUERY_EXPR = 191;
	int TYPE_NAME_REF = 192;
	int TYPE_NAME = 193;
	int SORTED_DEF = 194;
	int RAISE_STATEMENT = 195;
	int PACKAGE_OBJ_SPEC = 196;
	int PROCEDURE_SPEC = 197;
	int SIMPLE_UPDATE_COMMAND = 198;
	int SUBQUERY_UPDATE_COMMAND = 199;
	int IMMEDIATE_COMMAND = 200;
	int FUNCTION_SPEC = 201;
	int NEGATE_FACTOR = 202;
	int TABLE_TYPE_REF = 203;
	int COLUMN_TYPE_REF = 204;
	int STATEMENT_ANNOT = 205;
	int ASTERISK_COLUMN = 206;
	int IDENT_ASTERISK_COLUMN = 207;
	int EXPR_COLUMN = 208;
	int TABLE_REF = 209;
	int TABLE_REF_WITH_LINK = 210;
	int FROM_SUBQUERY = 211;
	int FROM_PLAIN_TABLE = 212;
	int SCHEMA_NAME = 213;
	int COLUMN_NAME_REF = 214;
	int ARITHMETIC_EXPR = 215;
	int ASSIGNMENT_OP = 216;
	int DBTIMEZONE = 217;
	int SUBQUERY_CONDITION = 218;
	int RECORD_ITEM = 219;
	int EXCEPTION_DECL = 220;
	int COMPLEX_NAME = 221;
	int CHARACTER_SET = 222;
	int AUTHID = 223;
	int RESTRICT_REF_PRAGMA = 224;
	int AUTONOMOUS_TRN_PRAGMA = 225;
	int EXCEPTION_PRAGMA = 226;
	int FIPSFLAG_PRAGMA = 227;
	int BUILTIN_PRAGMA = 228;
	int INTERFACE_PRAGMA = 229;
	int TIMESTAMPG_PRAGMA = 230;
	int SERIALLY_REUSABLE_PRAGMA = 231;
	int TIMESTAMP_CONST = 232;
	int SUBTYPE_DECL = 233;
	int MEMBER_OF = 234;
	int SQLPLUS_SET = 235;
	int SQLPLUS_SHOW = 236;
	int SQLPLUS_DEFINE = 237;
	int SQLPLUS_VARIABLE = 238;
	int SQLPLUS_EXEC = 239;
	int SQLPLUS_WHENEVER = 240;
	int SQLPLUS_PROMPT = 241;
	int SQLPLUS_COLUMN = 242;
	int SQLPLUS_START = 243;
	int SQLPLUS_SERVEROUTPUT = 244;
	int SQLPLUS_REPFOOTER = 245;
	int SQLPLUS_REPHEADER = 246;
	int SQLPLUS_EXIT = 247;
	int SQLPLUS_QUIT = 248;
	int SQLPLUS_RUNSCRIPT = 249;
	int SQLPLUS_SPOOL = 250;
	int CONSUMED_TILL_EOL = 251;
	int OR_LOGICAL = 252;
	int AND_LOGICAL = 253;
	int NOT_LOGICAL = 254;
	int LOGICAL_EXPR = 255;
	int RELATION_OP = 256;
	int SEQUENCE_EXPR = 257;
	int SEQUENCE_REF = 258;
	int ALIAS_IDENT = 259;
	int COLUMN_NAME_DDL = 260;
	int COLUMN_DEF = 261;
	int TABLE_DEF = 262;
	int A_COLUMN_DEF = 263;
	int TABLE_COLLECTION = 264;
	int VARRAY_COLLECTION = 265;
	int REF_CURSOR = 266;
	int OBJECT_TYPE_DEF = 267;
	int AT_TIME_ZONE_EXPR = 268;
	int TIMEZONE_SPEC = 269;
	int GRANT_COMMAND = 270;
	int REVOKE_COMMAND = 271;
	int ALTER_TABLE = 272;
	int ALTER_GENERIC = 273;
	int ALTER_TABLE_CONSTRAINT = 274;
	int CREATE_TEMP_TABLE = 275;
	int COMMENT_STMT = 276;
	int COMMENT_STR = 277;
	int CREATE_INDEX = 278;
	int INSERT_INTO_SUBQUERY_COMMAND = 279;
	int CONDITIONAL_COMPILATION = 280;
	int COND_COMP_SEQ = 281;
	int COND_COMP_SEQ2 = 282;
	int COND_COMP_ERROR = 283;
	int COLUMN_NAME_LIST = 284;
	int OWNER_COLUMN_NAME_LIST = 285;
	int CREATE_VIEW = 286;
	int CREATE_MATERIALIZED_VIEW = 287;
	int CREATE_MATERIALIZED_VIEW_LOG = 288;
	int DATATYPE_PARAM_INFO = 289;
	int CREATE_VIEW_COLUMN_DEF = 290;
	int TABLE_FUNCTION = 291;
	int ROWNUM = 292;
	int ROWID = 293;
	int CUSTOM_AGGR_FUNCTION = 294;
	int LAST_STMT_RESULT_NUM = 295;
	int LAST_STMT_RESULT_BOOL = 296;
	int SQL_CURSOR_FAKE_ATTR = 297;
	int CURRENT_OF_CLAUSE = 298;
	int CURSOR_STATE = 299;
	int SQLCODE_SYSVAR = 300;
	int SQLERRM_SYSVAR = 301;
	int COLLECTION_METHOD_CALL = 302;
	int COLLECTION_METHOD_CALL2 = 303;
	int C_RECORD_ITEM_REF = 304;
	int CALLABLE_NAME_REF = 305;
	int BUILTIN_FUNC_NAME = 306;
	int TRUNCATE_TABLE = 307;
	int DROP_VIEW = 308;
	int DROP_TABLE = 309;
	int DROP_FUNCTION = 310;
	int DROP_PROCEDURE = 311;
	int DROP_PACKAGE = 312;
	int DROP_INDEX = 313;
	int DROP_SEQUENCE = 314;
	int DROP_TYPE = 315;
	int DROP_OPERATOR = 316;
	int DROP_SYNONYM = 317;
	int DROP_USER = 318;
	int DROP_ROLE = 319;
	int DROP_LIBRARY = 320;
	int DROP_DB_LINK = 321;
	int DROP_DIRECTORY = 322;
	int DROP_TRIGGER = 323;
	int CREATE_SYNONYM = 324;
	int SYNONYM_NAME = 325;
	int SYNONYM_OBJ = 326;
	int SYNONYM_OBJ_WITH_LINK = 327;
	int COLUMN_PK_SPEC = 328;
	int COLUMN_FK_SPEC = 329;
	int NOT_NULL_STMT = 330;
	int COLUMN_CHECK_CONSTRAINT = 331;
	int COLUMN_NOT_NULL_CONSTRAINT = 332;
	int PK_SPEC = 333;
	int FK_SPEC = 334;
	int UNIQUE_CONSTRAINT = 335;
	int CHECK_CONSTRAINT = 336;
	int CONSTRAINT_NAME = 337;
	int ADD_CONSTRAINT = 338;
	int ADD_PRIMARY_KEY = 339;
	int ALTER_COLUMN_SPEC = 340;
	int IOT_TYPE = 341;
	int HEAP_ORGINIZED = 342;
	int EXTERNAL_TYPE = 343;
	int EXTERNAL_TABLE_SPEC = 344;
	int WRITE_ACCESS_PARAMS_SPEC = 345;
	int LOADER_ACCESS_PARAMS = 346;
	int EXT_FIELD_SPEC_LIST = 347;
	int EXT_FIELD_SPEC = 348;
	int RECORD_FMT_SPEC = 349;
	int EXT_TABLE_LOCATION_SPEC = 350;
	int STORAGE_PARAM = 351;
	int STORAGE_SPEC = 352;
	int PARALLEL_CLAUSE = 353;
	int REJECT_SPEC = 354;
	int NAME_FRAGMENT = 355;
	int EXEC_NAME_REF = 356;
	int COLLECTION_METHOD_NAME = 357;
	int V_COLUMN_DEF = 358;
	int TABLE_NAME_DDL = 359;
	int VIEW_NAME = 360;
	int INDEX_NAME = 361;
	int VIEW_NAME_DDL = 362;
	int SEQUENCE_NAME = 363;
	int USER_NAME = 364;
	int USER_ROLE = 365;
	int SYSTEM_PRIVILEGE = 366;
	int CREATE_TRIGGER = 367;
	int CREATE_DIRECTORY = 368;
	int CREATE_DB_LINK = 369;
	int CREATE_SEQUENCE = 370;
	int TRIGGER_FOR_EACH = 371;
	int TRIGGER_NAME = 372;
	int ALTER_TRIGGER = 373;
	int DB_EVNT_TRIGGER_CLAUSE = 374;
	int DDL_TRIGGER_CLAUSE = 375;
	int DML_TRIGGER_CLAUSE = 376;
	int TRIGGER_COLUMN_REF = 377;
	int INSTEADOF_TRIGGER = 378;
	int TRIGGER_TARGET = 379;
	int FORALL_LOOP_SPEC = 380;
	int CURSOR_REF_LOOP_SPEC = 381;
	int CURSOR_LOOP_SPEC = 382;
	int CURSOR_LOOP_INDEX = 383;
	int NUM_LOOP_INDEX = 384;
	int NUMERIC_LOOP_SPEC = 385;
	int RECORD_ITEM_NAME = 386;
	int GOTO_STATEMENT = 387;
	int EXIT_STATEMENT = 388;
	int LABEL_NAME = 389;
	int PARTITION_SPEC = 390;
	int RANGE_PARTITION = 391;
	int HASH_PARTITION = 392;
	int MONITORING_CLAUSE = 393;
	int CREATE_TABLESPACE = 394;
	int DROP_TABLESPACE = 395;
	int TABLESPACE_NAME = 396;
	int ALTER_TABLESPACE = 397;
	int CREATE_USER = 398;
	int CREATE_TYPE = 399;
	int BIND_VAR = 400;
	int RETURNING_CLAUSE = 401;
	int ALTER_INDEX = 402;
	int RENAME_TABLE = 403;
	int ALTER_TABLE_RENAME_CONSTR = 404;
	int ALTER_TABLE_RENAME_COL = 405;
	int ALTER_TABLE_DROP_COL = 406;
	int ALTER_TABLE_DROP_PK = 407;
	int ALTER_TABLE_DROP_CONSTR = 408;
	int TABLE_REF_NOT_RESOLVED = 409;
	int VIEW_NAME_REF = 410;
	int TABLE_NAME_REF = 411;
	int GENERIC_REF = 412;
	int CALL_NOT_RESOLVED = 413;
	int BUILT_IT_FUNCTION_CALL = 414;
	int UDF_CALL = 415;
	int UDP_CALL = 416;
	int LITERAL_package = 417;
	int LITERAL_body = 418;
	int LITERAL_alter = 419;
	int LITERAL_drop = 420;
	int LITERAL_table = 421;
	int LITERAL_purge = 422;
	int LITERAL_view = 423;
	int LITERAL_cascade = 424;
	int LITERAL_constraints = 425;
	int LITERAL_function = 426;
	int LITERAL_procedure = 427;
	int LITERAL_index = 428;
	int LITERAL_force = 429;
	int LITERAL_sequence = 430;
	int LITERAL_type = 431;
	int LITERAL_validate = 432;
	int LITERAL_public = 433;
	int LITERAL_synonym = 434;
	int LITERAL_operator = 435;
	int LITERAL_user = 436;
	int LITERAL_role = 437;
	int LITERAL_directory = 438;
	int LITERAL_library = 439;
	int LITERAL_database = 440;
	int LITERAL_link = 441;
	int LITERAL_trigger = 442;
	int LITERAL_associate = 443;
	int LITERAL_statistics = 444;
	int LITERAL_with = 445;
	int LITERAL_column = 446;
	int LITERAL_functions = 447;
	int LITERAL_packages = 448;
	int LITERAL_types = 449;
	int LITERAL_indexes = 450;
	int LITERAL_indextypes = 451;
	int LITERAL_system = 452;
	int LITERAL_managed = 453;
	int LITERAL_storage = 454;
	int LITERAL_default = 455;
	int LITERAL_cost = 456;
	int LITERAL_selectivity = 457;
	int LITERAL_using = 458;
	int LITERAL_null = 459;
	int LITERAL_truncate = 460;
	int LITERAL_comment = 461;
	int LITERAL_on = 462;
	int LITERAL_is = 463;
	int LITERAL_not = 464;
	int LITERAL_disable = 465;
	int LITERAL_enable = 466;
	int LITERAL_row = 467;
	int LITERAL_movement = 468;
	int LITERAL_constraint = 469;
	int LITERAL_primary = 470;
	int LITERAL_key = 471;
	int LITERAL_references = 472;
	int LITERAL_rely = 473;
	int LITERAL_check = 474;
	int LITERAL_unique = 475;
	int LITERAL_sysdate = 476;
	int LITERAL_systimestamp = 477;
	int LITERAL_set = 478;
	int LITERAL_long = 479;
	int LITERAL_show = 480;
	int LITERAL_var = 481;
	int LITERAL_variable = 482;
	int LITERAL_col = 483;
	int LITERAL_exec = 484;
	int LITERAL_execute = 485;
	int LITERAL_whenever = 486;
	int LITERAL_sqlerror = 487;
	int LITERAL_oserror = 488;
	int LITERAL_exit = 489;
	int LITERAL_continue = 490;
	int LITERAL_commit = 491;
	int LITERAL_rollback = 492;
	int LITERAL_none = 493;
	int LITERAL_def = 494;
	int LITERAL_define = 495;
	int LITERAL_prompt = 496;
	int LITERAL_rem = 497;
	int LITERAL_host = 498;
	int LITERAL_quit = 499;
	int LITERAL_spool = 500;
	int LITERAL_sta = 501;
	int LITERAL_start = 502;
	int LITERAL_repfooter = 503;
	int LITERAL_off = 504;
	int LITERAL_repheader = 505;
	int LITERAL_serveroutput = 506;
	int LITERAL_begin = 507;
	int LITERAL_declare = 508;
	int DOUBLE_DOT = 509;
	int LITERAL_rename = 510;
	int LITERAL_create = 511;
	int LITERAL_or = 512;
	int LITERAL_replace = 513;
	int LITERAL_materialized = 514;
	int LITERAL_log = 515;
	int LITERAL_global = 516;
	int LITERAL_temporary = 517;
	int LITERAL_under = 518;
	int LITERAL_final = 519;
	int LITERAL_as = 520;
	int LITERAL_object = 521;
	int LITERAL_identified = 522;
	int LITERAL_by = 523;
	int LITERAL_externally = 524;
	int LITERAL_globally = 525;
	int LITERAL_tablespace = 526;
	int LITERAL_quota = 527;
	int LITERAL_unlimited = 528;
	int LITERAL_profile = 529;
	int LITERAL_password = 530;
	int LITERAL_expire = 531;
	int LITERAL_account = 532;
	int LITERAL_lock = 533;
	int LITERAL_unlock = 534;
	int LITERAL_bigfile = 535;
	int LITERAL_smallfile = 536;
	int LITERAL_tempfile = 537;
	int LITERAL_undo = 538;
	int LITERAL_datafile = 539;
	int LITERAL_next = 540;
	int LITERAL_maxsize = 541;
	int LITERAL_size = 542;
	int LITERAL_reuse = 543;
	int LITERAL_extent = 544;
	int LITERAL_management = 545;
	int LITERAL_local = 546;
	int LITERAL_uniform = 547;
	int LITERAL_dictionary = 548;
	int LITERAL_retention = 549;
	int LITERAL_guarantee = 550;
	int LITERAL_noguarantee = 551;
	int LITERAL_autoextend = 552;
	int LITERAL_group = 553;
	int LITERAL_logging = 554;
	int LITERAL_nologging = 555;
	int LITERAL_no = 556;
	int LITERAL_online = 557;
	int LITERAL_offline = 558;
	int LITERAL_normal = 559;
	int LITERAL_immediate = 560;
	int LITERAL_read = 561;
	int LITERAL_only = 562;
	int LITERAL_write = 563;
	int LITERAL_permanent = 564;
	int LITERAL_including = 565;
	int LITERAL_contents = 566;
	int LITERAL_and = 567;
	int LITERAL_datafiles = 568;
	int LITERAL_add = 569;
	int LITERAL_to = 570;
	int LITERAL_end = 571;
	int LITERAL_backup = 572;
	int LITERAL_coalesce = 573;
	int LITERAL_minimum = 574;
	int LITERAL_maxvalue = 575;
	int LITERAL_minvalue = 576;
	int LITERAL_cycle = 577;
	int LITERAL_nocycle = 578;
	int LITERAL_cache = 579;
	int LITERAL_nocache = 580;
	int LITERAL_increment = 581;
	int LITERAL_order = 582;
	int LITERAL_noorder = 583;
	int LITERAL_for = 584;
	int LITERAL_connect = 585;
	int LITERAL_after = 586;
	int LITERAL_before = 587;
	int LITERAL_startup = 588;
	int LITERAL_shutdown = 589;
	int LITERAL_servererror = 590;
	int LITERAL_logon = 591;
	int LITERAL_logoff = 592;
	int LITERAL_analyze = 593;
	int LITERAL_audit = 594;
	int LITERAL_noaudit = 595;
	int LITERAL_ddl = 596;
	int LITERAL_diassociate = 597;
	int LITERAL_grant = 598;
	int LITERAL_revoke = 599;
	int LITERAL_schema = 600;
	int LITERAL_instead = 601;
	int LITERAL_of = 602;
	int LITERAL_delete = 603;
	int LITERAL_insert = 604;
	int LITERAL_update = 605;
	int LITERAL_each = 606;
	int LITERAL_referencing = 607;
	int LITERAL_old = 608;
	int LITERAL_new = 609;
	int LITERAL_when = 610;
	int LITERAL_bitmap = 611;
	int LITERAL_asc = 612;
	int LITERAL_desc = 613;
	int LITERAL_preserve = 614;
	int LITERAL_rows = 615;
	int LITERAL_nested = 616;
	int LITERAL_store = 617;
	int LITERAL_return = 618;
	int LITERAL_locator = 619;
	int LITERAL_value = 620;
	int LITERAL_lob = 621;
	int LITERAL_chunk = 622;
	int LITERAL_reads = 623;
	int LITERAL_pctversion = 624;
	int LITERAL_freepools = 625;
	int LITERAL_in = 626;
	int LITERAL_segment = 627;
	int LITERAL_creation = 628;
	int LITERAL_deferred = 629;
	int LITERAL_cluster = 630;
	int LITERAL_pctthreshold = 631;
	int LITERAL_filesystem_like_logging = 632;
	int LITERAL_compress = 633;
	int LITERAL_all = 634;
	int LITERAL_direct_load = 635;
	int LITERAL_operations = 636;
	int LITERAL_nocompress = 637;
	int LITERAL_pctfree = 638;
	int LITERAL_pctused = 639;
	int LITERAL_initrans = 640;
	int LITERAL_maxtrans = 641;
	int LITERAL_compute = 642;
	int LITERAL_parallel = 643;
	int LITERAL_noparallel = 644;
	int LITERAL_monitoring = 645;
	int LITERAL_nomonitoring = 646;
	int LITERAL_overflow = 647;
	int LITERAL_partition = 648;
	int LITERAL_range = 649;
	int LITERAL_interval = 650;
	int LITERAL_values = 651;
	int LITERAL_less = 652;
	int LITERAL_than = 653;
	int LITERAL_hash = 654;
	int LITERAL_partitions = 655;
	int LITERAL_novalidate = 656;
	int LITERAL_organization = 657;
	int LITERAL_heap = 658;
	int LITERAL_external = 659;
	int LITERAL_degree = 660;
	int LITERAL_instances = 661;
	int LITERAL_reject = 662;
	int LITERAL_limit = 663;
	int LITERAL_initial = 664;
	int LITERAL_minextents = 665;
	int LITERAL_maxextents = 666;
	int LITERAL_pctincrease = 667;
	int LITERAL_freelists = 668;
	int LITERAL_freelist = 669;
	int LITERAL_groups = 670;
	int LITERAL_optimal = 671;
	int LITERAL_buffer_pool = 672;
	int LITERAL_keep = 673;
	int LITERAL_recycle = 674;
	int LITERAL_flash_cache = 675;
	int LITERAL_cell_flash_cache = 676;
	int LITERAL_encrypt = 677;
	int LITERAL_foreign = 678;
	int LITERAL_restrict = 679;
	int LITERAL_action = 680;
	int LITERAL_modify = 681;
	int LITERAL_sort = 682;
	int LITERAL_nosort = 683;
	int LITERAL_reverse = 684;
	int LITERAL_visible = 685;
	int LITERAL_novisible = 686;
	int LITERAL_record = 687;
	int LITERAL_ref = 688;
	int LITERAL_cursor = 689;
	int LITERAL_rowtype = 690;
	int LITERAL_varray = 691;
	int LITERAL_option = 692;
	int LITERAL_prebuilt = 693;
	int LITERAL_without = 694;
	int LITERAL_reduced = 695;
	int LITERAL_precision = 696;
	int LITERAL_excluding = 697;
	int LITERAL_rowid = 698;
	int LITERAL_query = 699;
	int LITERAL_rewrite = 700;
	int LITERAL_never = 701;
	int LITERAL_refresh = 702;
	int LITERAL_build = 703;
	int LITERAL_fast = 704;
	int LITERAL_complete = 705;
	int LITERAL_demand = 706;
	// "view_column_def_$internal$" = 707
	int LITERAL_timestamp = 708;
	int LITERAL_authid = 709;
	int LITERAL_wrapped = 710;
	int LITERAL_pragma = 711;
	int LITERAL_restrict_references = 712;
	int LITERAL_interface = 713;
	int LITERAL_builtin = 714;
	int LITERAL_fipsflag = 715;
	int LITERAL_exception_init = 716;
	int LITERAL_constant = 717;
	int LITERAL_subtype = 718;
	int LITERAL_loop = 719;
	int LITERAL_while = 720;
	int LITERAL_sql = 721;
	int LITERAL_found = 722;
	int LITERAL_notfound = 723;
	int LITERAL_rowcount = 724;
	int LITERAL_isopen = 725;
	int LITERAL_bulk_rowcount = 726;
	int LITERAL_bulk_exceptions = 727;
	int LITERAL_error_index = 728;
	int LITERAL_error_code = 729;
	int LITERAL_count = 730;
	int LITERAL_case = 731;
	int LITERAL_then = 732;
	int LITERAL_else = 733;
	int LITERAL_autonomous_transaction = 734;
	int LITERAL_prior = 735;
	int LITERAL_goto = 736;
	int LITERAL_number = 737;
	int LITERAL_binary_integer = 738;
	int LITERAL_natural = 739;
	int LITERAL_positive = 740;
	int LITERAL_char = 741;
	int LITERAL_byte = 742;
	int LITERAL_raw = 743;
	int LITERAL_boolean = 744;
	int LITERAL_date = 745;
	int LITERAL_time = 746;
	int LITERAL_zone = 747;
	int LITERAL_year = 748;
	int LITERAL_month = 749;
	int LITERAL_day = 750;
	int LITERAL_second = 751;
	int LITERAL_smallint = 752;
	int LITERAL_real = 753;
	int LITERAL_numeric = 754;
	int LITERAL_int = 755;
	int LITERAL_integer = 756;
	int LITERAL_pls_integer = 757;
	int LITERAL_double = 758;
	int LITERAL_float = 759;
	int LITERAL_decimal = 760;
	int LITERAL_varchar = 761;
	// "varchar2" = 762
	int LITERAL_nvarchar = 763;
	// "nvarchar2" = 764
	int LITERAL_character = 765;
	int LITERAL_blob = 766;
	int LITERAL_clob = 767;
	int LITERAL_nclob = 768;
	int LITERAL_bfile = 769;
	int LITERAL_out = 770;
	int LITERAL_nocopy = 771;
	int LITERAL_any_cs = 772;
	int LITERAL_charset = 773;
	int LITERAL_exception = 774;
	int LITERAL_serially_reusable = 775;
	int LITERAL_pipelined = 776;
	int LITERAL_parallel_enable = 777;
	int LITERAL_deterministic = 778;
	int LITERAL_result_cache = 779;
	int LITERAL_relies_on = 780;
	int LITERAL_language = 781;
	int LITERAL_java = 782;
	int LITERAL_name = 783;
	int LITERAL_raise = 784;
	int LITERAL_save = 785;
	int LITERAL_exceptions = 786;
	int LITERAL_forall = 787;
	int LITERAL_indices = 788;
	int LITERAL_true = 789;
	int LITERAL_false = 790;
	// "**" = 791
	int LITERAL_at = 792;
	int LITERAL_current = 793;
	int LITERAL_exists = 794;
	int LITERAL_select = 795;
	int LITERAL_like = 796;
	int LITERAL_escape = 797;
	int LITERAL_between = 798;
	int LITERAL_member = 799;
	int LITERAL_sqlcode = 800;
	int LITERAL_sqlerrm = 801;
	int LITERAL_cast = 802;
	int LITERAL_decode = 803;
	int LITERAL_trim = 804;
	int LITERAL_multiset = 805;
	int LITERAL_lag = 806;
	int LITERAL_lead = 807;
	int LITERAL_rank = 808;
	int LITERAL_dense_rank = 809;
	int LITERAL_extract = 810;
	int LITERAL_minute = 811;
	int LITERAL_hour = 812;
	int LITERAL_any = 813;
	int LITERAL_nextval = 814;
	int LITERAL_currval = 815;
	int LITERAL_over = 816;
	int LITERAL_sessiontimezone = 817;
	int LITERAL_dbtimezone = 818;
	int LITERAL_distinct = 819;
	int LITERAL_from = 820;
	int LITERAL_timezone_hour = 821;
	int LITERAL_timezone_minute = 822;
	int LITERAL_timezone_region = 823;
	int LITERAL_timezone_abbr = 824;
	int LITERAL_leading = 825;
	int LITERAL_trailing = 826;
	int LITERAL_both = 827;
	int LITERAL_work = 828;
	int LITERAL_if = 829;
	int LITERAL_elsif = 830;
	int LITERAL_privileges = 831;
	int LITERAL_hierarchy = 832;
	int LITERAL_debug = 833;
	int LITERAL_admin = 834;
	int LITERAL_resource = 835;
	int LITERAL_indextype = 836;
	int LITERAL_session = 837;
	int LITERAL_become = 838;
	int LITERAL_union = 839;
	int LITERAL_intersect = 840;
	int LITERAL_minus = 841;
	int LITERAL_bulk = 842;
	int LITERAL_collect = 843;
	int LITERAL_into = 844;
	int LITERAL_flush = 845;
	int LITERAL_shared_pool = 846;
	int LITERAL_reset = 847;
	int LITERAL_sid = 848;
	int LITERAL_rebuild = 849;
	int LITERAL_unusable = 850;
	int LITERAL_left = 851;
	int LITERAL_right = 852;
	int LITERAL_inner = 853;
	int LITERAL_full = 854;
	int LITERAL_where = 855;
	int LITERAL_current_timestamp = 856;
	int LITERAL_rownum = 857;
	int LITERAL_the = 858;
	int LITERAL_outer = 859;
	int LITERAL_join = 860;
	int LITERAL_having = 861;
	int LITERAL_nulls = 862;
	int LITERAL_first = 863;
	int LITERAL_last = 864;
	int LITERAL_nowait = 865;
	int LITERAL_wait = 866;
	int LITERAL_merge = 867;
	int LITERAL_matched = 868;
	int LITERAL_returning = 869;
	int LITERAL_transaction = 870;
	int LITERAL_close = 871;
	int LITERAL_fetch = 872;
	int LITERAL_mode = 873;
	int LITERAL_share = 874;
	int LITERAL_exclusive = 875;
	int LITERAL_open = 876;
	int LITERAL_savepoint = 877;
	int LITERAL_oracle_loader = 878;
	int LITERAL_oracle_datapump = 879;
	int LITERAL_access = 880;
	int LITERAL_parameters = 881;
	int LITERAL_nologfile = 882;
	int LITERAL_logfile = 883;
	int LITERAL_version = 884;
	int LITERAL_compatible = 885;
	int LITERAL_latest = 886;
	int LITERAL_compression = 887;
	int LITERAL_enabled = 888;
	int LITERAL_disabled = 889;
	int LITERAL_encryption = 890;
	int LITERAL_records = 891;
	int LITERAL_fixed = 892;
	int LITERAL_delimited = 893;
	int LITERAL_newline = 894;
	int LITERAL_characterset = 895;
	int LITERAL_data = 896;
	int LITERAL_big = 897;
	int LITERAL_little = 898;
	int LITERAL_endian = 899;
	int LITERAL_mark = 900;
	int LITERAL_nocheck = 901;
	int LITERAL_string = 902;
	int LITERAL_sizes = 903;
	int LITERAL_bytes = 904;
	int LITERAL_characters = 905;
	int LITERAL_load = 906;
	int LITERAL_nobadfile = 907;
	int LITERAL_badfile = 908;
	int LITERAL_nodiscardfile = 909;
	int LITERAL_discardfile = 910;
	int LITERAL_readsize = 911;
	int LITERAL_data_cache = 912;
	int LITERAL_skip = 913;
	int LITERAL_preprocessor = 914;
	int LITERAL_fields = 915;
	int LITERAL_missing = 916;
	int LITERAL_field = 917;
	int LITERAL_are = 918;
	int LITERAL_transforms = 919;
	int LITERAL_concat = 920;
	int LITERAL_lobfile = 921;
	int LITERAL_enclosed = 922;
	int LITERAL_terminated = 923;
	int LITERAL_whitespace = 924;
	int LITERAL_optionally = 925;
	int LITERAL_lrtrim = 926;
	int LITERAL_notrim = 927;
	int LITERAL_ltrim = 928;
	int LITERAL_rtrim = 929;
	int LITERAL_ldrtrim = 930;
	int LITERAL_position = 931;
	int LITERAL_unsigned = 932;
	int LITERAL_zoned = 933;
	int LITERAL_oracle_date = 934;
	int LITERAL_oracle_number = 935;
	int LITERAL_counted = 936;
	int LITERAL_varraw = 937;
	int LITERAL_varcharc = 938;
	int LITERAL_varrawc = 939;
	int LITERAL_date_format = 940;
	int LITERAL_timezone = 941;
	int LITERAL_mask = 942;
	int LITERAL_location = 943;
	int LITERAL_aggregate = 944;
	int LITERAL_ldtrim = 945;
}
